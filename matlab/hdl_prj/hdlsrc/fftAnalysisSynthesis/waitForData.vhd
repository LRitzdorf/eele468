-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/fftAnalysisSynthesis/waitForData.vhd
-- 
-- Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: waitForData
-- Source Path: fftAnalysisSynthesis/fftAnalysisSynthesis/analysis/fftFrameBuffering/fftPulseGen/waitForData
-- Hierarchy Level: 4
-- Model version: 8.3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.fftAnalysisSynthesis_pkg.ALL;

ENTITY waitForData IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_2048_1                      :   IN    std_logic;
        framePulse                        :   IN    std_logic;
        fftFramePulse                     :   OUT   std_logic
        );
END waitForData;


ARCHITECTURE rtl OF waitForData IS

  ATTRIBUTE multstyle : string;

  -- Signals
  SIGNAL framePulse_1                     : std_logic;
  SIGNAL count_step                       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_from                       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL initialFrameCount_out1           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count                            : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_1                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL need_to_wrap                     : std_logic;
  SIGNAL need_to_wrap_1                   : std_logic;
  SIGNAL count_value                      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_value_1                    : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL rd_1_reg                         : vector_of_unsigned5(0 TO 1);  -- ufix5 [2]
  SIGNAL initialFrameCount_out1_1         : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL rd_0_reg                         : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Logical_Operator_out1_1          : std_logic;
  SIGNAL count_2                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_3                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL initialFrameCount_bypass_reg     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL initialFrameCount_out1_2         : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Bitwise_Operator_out1            : std_logic;
  SIGNAL Logical_Operator1_out1           : std_logic;
  SIGNAL t_bypass_reg                     : std_logic;  -- ufix1
  SIGNAL Logical_Operator1_out1_1         : std_logic;

BEGIN
  -- Frame pulses don't start
  -- coming through until 
  -- circular buffer has data.  
  -- Counter starts a zero and counts number of frame pulses.
  -- Counter remains enabled while frame count is less than 4.
  -- As soon as the counter reaches 4, it is disabled, which then
  -- enables the frame pulses to pass through.
  -- framePulse
  -- will pass through 
  -- when enabled
  -- Number of Frames
  -- to wait before starting
  -- Start performing FFTs after enough data has filled the circular buffer.
  -- This is due to the fact that we don't want the read pointer (addrB) 
  -- to catch up with the  write pointer (addrA) because if it does,
  -- the dpRAM will throw an assertion error.

  framePulse_1 <= framePulse;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 4
  count_step <= to_unsigned(16#01#, 5);

  count_from <= to_unsigned(16#00#, 5);

  count <= initialFrameCount_out1 + count_step;

  rd_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_1 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        count_1 <= count;
      END IF;
    END IF;
  END PROCESS rd_4_process;


  
  need_to_wrap <= '1' WHEN initialFrameCount_out1 = to_unsigned(16#04#, 5) ELSE
      '0';

  rd_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      need_to_wrap_1 <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        need_to_wrap_1 <= need_to_wrap;
      END IF;
    END IF;
  END PROCESS rd_3_process;


  
  count_value <= count_1 WHEN need_to_wrap_1 = '0' ELSE
      count_from;

  rd_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_value_1 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        count_value_1 <= count_value;
      END IF;
    END IF;
  END PROCESS rd_5_process;


  rd_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rd_1_reg <= (OTHERS => to_unsigned(16#00#, 5));
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        rd_1_reg(0) <= initialFrameCount_out1;
        rd_1_reg(1) <= rd_1_reg(0);
      END IF;
    END IF;
  END PROCESS rd_1_process;

  initialFrameCount_out1_1 <= rd_1_reg(1);

  Logical_Operator_out1 <= Compare_To_Constant_out1 AND framePulse_1;

  rd_0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rd_0_reg <= (OTHERS => '0');
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        rd_0_reg(0) <= Logical_Operator_out1;
        rd_0_reg(1) <= rd_0_reg(0);
      END IF;
    END IF;
  END PROCESS rd_0_process;

  Logical_Operator_out1_1 <= rd_0_reg(1);

  
  count_2 <= initialFrameCount_out1_1 WHEN Logical_Operator_out1_1 = '0' ELSE
      count_value_1;

  crp_out_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_3 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        count_3 <= count_2;
      END IF;
    END IF;
  END PROCESS crp_out_delay_process;


  initialFrameCount_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      initialFrameCount_bypass_reg <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_1 = '1' THEN
        initialFrameCount_bypass_reg <= count_3;
      END IF;
    END IF;
  END PROCESS initialFrameCount_bypass_process;

  
  initialFrameCount_out1_2 <= count_3 WHEN enb_1_2048_1 = '1' ELSE
      initialFrameCount_bypass_reg;

  initialFrameCount_out1 <= initialFrameCount_out1_2;

  
  Compare_To_Constant_out1 <= '1' WHEN initialFrameCount_out1 < to_unsigned(16#04#, 5) ELSE
      '0';

  Bitwise_Operator_out1 <=  NOT Compare_To_Constant_out1;

  Logical_Operator1_out1 <= framePulse_1 AND Bitwise_Operator_out1;

  t_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      t_bypass_reg <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_1 = '1' THEN
        t_bypass_reg <= Logical_Operator1_out1;
      END IF;
    END IF;
  END PROCESS t_bypass_process;

  
  Logical_Operator1_out1_1 <= Logical_Operator1_out1 WHEN enb_1_2048_1 = '1' ELSE
      t_bypass_reg;

  fftFramePulse <= Logical_Operator1_out1_1;

END rtl;

