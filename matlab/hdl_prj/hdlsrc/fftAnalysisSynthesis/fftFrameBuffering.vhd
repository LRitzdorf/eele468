-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/fftAnalysisSynthesis/fftFrameBuffering.vhd
-- 
-- Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: fftFrameBuffering
-- Source Path: fftAnalysisSynthesis/fftAnalysisSynthesis/analysis/fftFrameBuffering
-- Hierarchy Level: 2
-- Model version: 8.2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.fftAnalysisSynthesis_pkg.ALL;

ENTITY fftFrameBuffering IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_2048_0                      :   IN    std_logic;
        enb_1_2048_1                      :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_4194304_1                   :   IN    std_logic;
        enb_1_4194304_0                   :   IN    std_logic;
        audioIn                           :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        passthrough                       :   IN    std_logic;  -- ufix1
        filterSelect                      :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        fftData                           :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        fftDataValid                      :   OUT   std_logic;
        startPulseFast                    :   OUT   std_logic;
        passthroughFast                   :   OUT   std_logic;  -- ufix1
        filterSelectFast                  :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
        );
END fftFrameBuffering;


ARCHITECTURE rtl OF fftFrameBuffering IS

  ATTRIBUTE multstyle : string;

  -- Component Declarations
  COMPONENT addrAoffset
    PORT( counterA                        :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          addrA                           :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT fftPulseGen
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_4194304_1                 :   IN    std_logic;
          counter                         :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          fftStartPulse                   :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT fastTransition
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2048_1                    :   IN    std_logic;
          enb_1_4194304_1                 :   IN    std_logic;
          enb_1_4194304_0                 :   IN    std_logic;
          fftStartPulseSlow               :   IN    std_logic;
          passthroughSlow                 :   IN    std_logic;  -- ufix1
          filterSelectSlow                :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          fftStartPulseFast               :   OUT   std_logic;
          passthroughFast                 :   OUT   std_logic;  -- ufix1
          filterSelectFast                :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
          );
  END COMPONENT;

  COMPONENT addrBgen
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          enb_1_2048_1                    :   IN    std_logic;
          enb                             :   IN    std_logic;
          fftStart                        :   IN    std_logic;
          addrB                           :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
          windowIndex                     :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
          fftValid                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT DualRateDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          enb_1_4194304_0                 :   IN    std_logic;
          din_A                           :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          addr_A                          :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          we_A                            :   IN    std_logic;
          din_B                           :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          addr_B                          :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          we_B                            :   IN    std_logic;
          doutA                           :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          doutB                           :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : addrAoffset
    USE ENTITY work.addrAoffset(rtl);

  FOR ALL : fftPulseGen
    USE ENTITY work.fftPulseGen(rtl);

  FOR ALL : fastTransition
    USE ENTITY work.fastTransition(rtl);

  FOR ALL : addrBgen
    USE ENTITY work.addrBgen(rtl);

  FOR ALL : DualRateDualPortRAM_generic
    USE ENTITY work.DualRateDualPortRAM_generic(rtl);

  -- Constants
  CONSTANT hanningROM_table_data          : vector_of_unsigned24(0 TO 127) := 
    (to_unsigned(16#0009B7#, 24), to_unsigned(16#0026D7#, 24), to_unsigned(16#00574D#, 24),
     to_unsigned(16#009AFC#, 24), to_unsigned(16#00F1BB#, 24), to_unsigned(16#015B56#, 24),
     to_unsigned(16#01D78C#, 24), to_unsigned(16#026612#, 24), to_unsigned(16#030691#, 24),
     to_unsigned(16#03B8A9#, 24), to_unsigned(16#047BEC#, 24), to_unsigned(16#054FE4#, 24),
     to_unsigned(16#063410#, 24), to_unsigned(16#0727E7#, 24), to_unsigned(16#082AD4#, 24),
     to_unsigned(16#093C39#, 24), to_unsigned(16#0A5B70#, 24), to_unsigned(16#0B87CC#, 24),
     to_unsigned(16#0CC096#, 24), to_unsigned(16#0E0510#, 24), to_unsigned(16#0F5475#, 24),
     to_unsigned(16#10ADF9#, 24), to_unsigned(16#1210CA#, 24), to_unsigned(16#137C12#, 24),
     to_unsigned(16#14EEF3#, 24), to_unsigned(16#16688C#, 24), to_unsigned(16#17E7F8#, 24),
     to_unsigned(16#196C4F#, 24), to_unsigned(16#1AF4A3#, 24), to_unsigned(16#1C8008#, 24),
     to_unsigned(16#1E0D8D#, 24), to_unsigned(16#1F9C40#, 24), to_unsigned(16#212B30#, 24),
     to_unsigned(16#22B96B#, 24), to_unsigned(16#2445FD#, 24), to_unsigned(16#25CFF8#, 24),
     to_unsigned(16#27566B#, 24), to_unsigned(16#28D86A#, 24), to_unsigned(16#2A5509#, 24),
     to_unsigned(16#2BCB63#, 24), to_unsigned(16#2D3A93#, 24), to_unsigned(16#2EA1BB#, 24),
     to_unsigned(16#300000#, 24), to_unsigned(16#31548E#, 24), to_unsigned(16#329E97#, 24),
     to_unsigned(16#33DD51#, 24), to_unsigned(16#350FFB#, 24), to_unsigned(16#3635DB#, 24),
     to_unsigned(16#374E3F#, 24), to_unsigned(16#38587C#, 24), to_unsigned(16#3953F0#, 24),
     to_unsigned(16#3A4004#, 24), to_unsigned(16#3B1C27#, 24), to_unsigned(16#3BE7D4#, 24),
     to_unsigned(16#3CA28F#, 24), to_unsigned(16#3D4BE8#, 24), to_unsigned(16#3DE376#, 24),
     to_unsigned(16#3E68DE#, 24), to_unsigned(16#3EDBCF#, 24), to_unsigned(16#3F3C03#, 24),
     to_unsigned(16#3F8941#, 24), to_unsigned(16#3FC358#, 24), to_unsigned(16#3FEA25#, 24),
     to_unsigned(16#3FFD92#, 24), to_unsigned(16#3FFD92#, 24), to_unsigned(16#3FEA25#, 24),
     to_unsigned(16#3FC358#, 24), to_unsigned(16#3F8941#, 24), to_unsigned(16#3F3C03#, 24),
     to_unsigned(16#3EDBCF#, 24), to_unsigned(16#3E68DE#, 24), to_unsigned(16#3DE376#, 24),
     to_unsigned(16#3D4BE8#, 24), to_unsigned(16#3CA28F#, 24), to_unsigned(16#3BE7D4#, 24),
     to_unsigned(16#3B1C27#, 24), to_unsigned(16#3A4004#, 24), to_unsigned(16#3953F0#, 24),
     to_unsigned(16#38587C#, 24), to_unsigned(16#374E3F#, 24), to_unsigned(16#3635DB#, 24),
     to_unsigned(16#350FFB#, 24), to_unsigned(16#33DD51#, 24), to_unsigned(16#329E97#, 24),
     to_unsigned(16#31548E#, 24), to_unsigned(16#300000#, 24), to_unsigned(16#2EA1BB#, 24),
     to_unsigned(16#2D3A93#, 24), to_unsigned(16#2BCB63#, 24), to_unsigned(16#2A5509#, 24),
     to_unsigned(16#28D86A#, 24), to_unsigned(16#27566B#, 24), to_unsigned(16#25CFF8#, 24),
     to_unsigned(16#2445FD#, 24), to_unsigned(16#22B96B#, 24), to_unsigned(16#212B30#, 24),
     to_unsigned(16#1F9C40#, 24), to_unsigned(16#1E0D8D#, 24), to_unsigned(16#1C8008#, 24),
     to_unsigned(16#1AF4A3#, 24), to_unsigned(16#196C4F#, 24), to_unsigned(16#17E7F8#, 24),
     to_unsigned(16#16688C#, 24), to_unsigned(16#14EEF3#, 24), to_unsigned(16#137C12#, 24),
     to_unsigned(16#1210CA#, 24), to_unsigned(16#10ADF9#, 24), to_unsigned(16#0F5475#, 24),
     to_unsigned(16#0E0510#, 24), to_unsigned(16#0CC096#, 24), to_unsigned(16#0B87CC#, 24),
     to_unsigned(16#0A5B70#, 24), to_unsigned(16#093C39#, 24), to_unsigned(16#082AD4#, 24),
     to_unsigned(16#0727E7#, 24), to_unsigned(16#063410#, 24), to_unsigned(16#054FE4#, 24),
     to_unsigned(16#047BEC#, 24), to_unsigned(16#03B8A9#, 24), to_unsigned(16#030691#, 24),
     to_unsigned(16#026612#, 24), to_unsigned(16#01D78C#, 24), to_unsigned(16#015B56#, 24),
     to_unsigned(16#00F1BB#, 24), to_unsigned(16#009AFC#, 24), to_unsigned(16#00574D#, 24),
     to_unsigned(16#0026D7#, 24), to_unsigned(16#0009B7#, 24));  -- ufix24 [128]

  -- Signals
  SIGNAL count_step                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL count_step_1                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL counterA_out1                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL counterA_out1_1                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL counterA_out1_2                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL count                            : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL count_1                          : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL counterA_bypass_reg              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL addrAoffset_out1                 : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Always_Write_A_out1              : std_logic;
  SIGNAL Never_Write_B_out1               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL fftPulseGen_out1                 : std_logic;
  SIGNAL fastTransition_out1              : std_logic;
  SIGNAL fastTransition_out2              : std_logic;  -- ufix1
  SIGNAL fastTransition_out3              : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL addrBgen_out1                    : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL addrBgen_out2                    : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL fftValid                         : std_logic;
  SIGNAL Always_Read_B_out1               : std_logic;
  SIGNAL dpRAM_out1                       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL dpRAM_out2                       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL dpRAM_out2_1                     : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL HwModeRegister_reg               : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL dpRAM_out2_2                     : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL addrBgen_out2_1                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL hanningROM_index                 : signed(31 DOWNTO 0);  -- int32
  SIGNAL hanningROM_out1                  : unsigned(23 DOWNTO 0);  -- ufix24_En22
  SIGNAL hanningROM_out1_1                : unsigned(23 DOWNTO 0) := to_unsigned(16#000000#, 24);  -- ufix24_En22
  SIGNAL hanningROM_out1_2                : unsigned(23 DOWNTO 0);  -- ufix24_En22
  SIGNAL Product_cast                     : signed(24 DOWNTO 0);  -- sfix25_En22
  SIGNAL Product_mul_temp                 : signed(48 DOWNTO 0);  -- sfix49_En45
  SIGNAL Product_cast_1                   : signed(47 DOWNTO 0);  -- sfix48_En45
  SIGNAL Product_out1                     : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product_out1_1                   : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL t_bypass_reg                     : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL Product_out1_2                   : signed(23 DOWNTO 0);  -- sfix24_En23

BEGIN
  -- When a FFT frame pulse
  -- is received, create addresses for
  -- Port B to stream a data frame
  -- to the FFT engine.
  -- Apply a Hanning Window
  -- before computing the FFT.  
  -- This is done by looking up 
  -- the appropiate Hanning value
  -- and applied to the data while 
  -- the data is streamed to the
  -- FFT engine.
  -- Frame pulses don't start
  -- until there is enough data
  -- in the circular buffer.
  -- The size of Dual Port RAM is specified by the variable 
  -- modelParams.dpram1.addressSize  and is typically twice the FFT size.  
  -- Ports A and B are running at different clock rates.
  -- Circular Buffer 
  -- Port A Address Generator
  -- Port A of Dual Port RAM
  -- 
  -- Data is written to circular buffer at input sample rate.
  -- Write is always enabled.  Port A is never read so output is ignored.
  -- Transition to
  -- Fast System Clock
  -- for FFT Processing 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- Port B of Dual Port RAM
  -- 
  -- Data is read from the circular buffer at a higher clock rate.
  -- Read is always enabled.  Port B never writes so input data to port B
  -- is ignored (specified as zero).

  u_addrAoffset : addrAoffset
    PORT MAP( counterA => std_logic_vector(counterA_out1),  -- uint8
              addrA => addrAoffset_out1  -- uint8
              );

  u_fftPulseGen : fftPulseGen
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              enb_1_4194304_1 => enb_1_4194304_1,
              counter => std_logic_vector(counterA_out1),  -- uint8
              fftStartPulse => fftPulseGen_out1
              );

  u_fastTransition : fastTransition
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2048_1 => enb_1_2048_1,
              enb_1_4194304_1 => enb_1_4194304_1,
              enb_1_4194304_0 => enb_1_4194304_0,
              fftStartPulseSlow => fftPulseGen_out1,
              passthroughSlow => passthrough,  -- ufix1
              filterSelectSlow => filterSelect,  -- ufix2
              fftStartPulseFast => fastTransition_out1,
              passthroughFast => fastTransition_out2,  -- ufix1
              filterSelectFast => fastTransition_out3  -- ufix2
              );

  u_addrBgen : addrBgen
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_2048_1 => enb_1_2048_1,
              enb => enb,
              fftStart => fastTransition_out1,
              addrB => addrBgen_out1,  -- uint8
              windowIndex => addrBgen_out2,  -- uint8
              fftValid => fftValid
              );

  u_dpRAM : DualRateDualPortRAM_generic
    GENERIC MAP( AddrWidth => 8,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_4194304_0 => enb_1_4194304_0,
              din_A => audioIn,
              addr_A => addrAoffset_out1,
              we_A => Always_Write_A_out1,
              din_B => std_logic_vector(Never_Write_B_out1),
              addr_B => addrBgen_out1,
              we_B => Always_Read_B_out1,
              doutA => dpRAM_out1,
              doutB => dpRAM_out2
              );

  count_step <= to_unsigned(16#01#, 8);

  rd_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_step_1 <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        count_step_1 <= count_step;
      END IF;
    END IF;
  END PROCESS rd_1_process;


  counterA_out1_1 <= counterA_out1;

  rd_0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      counterA_out1_2 <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        counterA_out1_2 <= counterA_out1_1;
      END IF;
    END IF;
  END PROCESS rd_0_process;


  count <= counterA_out1_2 + count_step_1;

  crp_out_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_1 <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        count_1 <= count;
      END IF;
    END IF;
  END PROCESS crp_out_delay_process;


  counterA_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      counterA_bypass_reg <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb_1_4194304_1 = '1' THEN
        counterA_bypass_reg <= count_1;
      END IF;
    END IF;
  END PROCESS counterA_bypass_process;

  
  counterA_out1 <= count_1 WHEN enb_1_4194304_1 = '1' ELSE
      counterA_bypass_reg;

  Always_Write_A_out1 <= '1';

  Never_Write_B_out1 <= to_signed(16#000000#, 24);

  Always_Read_B_out1 <= '0';

  dpRAM_out2_1 <= signed(dpRAM_out2);

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HwModeRegister_reg <= (OTHERS => to_signed(16#000000#, 24));
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        HwModeRegister_reg(0) <= dpRAM_out2_1;
        HwModeRegister_reg(1) <= HwModeRegister_reg(0);
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;

  dpRAM_out2_2 <= HwModeRegister_reg(1);

  addrBgen_out2_1 <= unsigned(addrBgen_out2);

  
  hanningROM_index <= to_signed(16#0000007F#, 32) WHEN addrBgen_out2_1 > to_unsigned(16#0000007F#, 8) ELSE
      signed(resize(addrBgen_out2_1, 32));
  hanningROM_out1 <= hanningROM_table_data(to_integer(hanningROM_index));

  PipelineRegister_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF enb = '1' THEN
        hanningROM_out1_1 <= hanningROM_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hanningROM_out1_2 <= to_unsigned(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        hanningROM_out1_2 <= hanningROM_out1_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Product_cast <= signed(resize(hanningROM_out1_2, 25));
  Product_mul_temp <= dpRAM_out2_2 * Product_cast;
  Product_cast_1 <= Product_mul_temp(47 DOWNTO 0);
  Product_out1 <= Product_cast_1(45 DOWNTO 22);

  PipelineRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_1 <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Product_out1_1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  t_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      t_bypass_reg <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_1 = '1' THEN
        t_bypass_reg <= Product_out1_1;
      END IF;
    END IF;
  END PROCESS t_bypass_process;

  
  Product_out1_2 <= Product_out1_1 WHEN enb_1_2048_1 = '1' ELSE
      t_bypass_reg;

  fftData <= std_logic_vector(Product_out1_2);

  fftDataValid <= fftValid;

  startPulseFast <= fastTransition_out1;

  passthroughFast <= fastTransition_out2;

  filterSelectFast <= fastTransition_out3;

END rtl;

